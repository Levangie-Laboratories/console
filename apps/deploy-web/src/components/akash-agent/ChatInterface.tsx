/**
 * @fileoverview Main chat interface component for the Akash AI Agent
 * 
 * This component manages the core chat functionality including:
 * - Real-time messaging with the Akash AI Agent
 * - SDL (Service Definition Language) generation and preview
 * - Connection status management and error handling
 * - Agent action streaming and processing
 * - Debug mode for development and testing
 * 
 * 
 * @version 2.0.0
 * @since 2024-06-29
 */

"use client";
import React, { useCallback, useEffect, useRef } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { cn } from '@akashnetwork/ui/utils';
import { ChatWelcomeScreen } from './ChatWelcomeScreen';
import { ChatMessageList } from './ChatMessageList';
import { ChatInput } from './ChatInput';
import { TypingIndicator } from './TypingIndicator';
import { useAkashAgent } from './hooks/useAkashAgent';
import { useChatState } from './hooks/useChatState';
import { useSDLGeneration } from './hooks/useSDLGeneration';
import type { ChatInterfaceProps, AgentAction } from './types';

/**
 * ChatInterface Component
 * 
 * The main chat interface that handles real-time communication with the Akash AI Agent.
 * Manages message flow, connection status, SDL generation, and provides debug capabilities.
 * 
 * @param onSDLGenerated - Callback when SDL is generated by the agent
 * @param onClose - Callback to close the chat interface
 * 
 * @features
 * - Real-time agent streaming with action processing
 * - Automatic connection testing and retry logic  
 * - SDL detection and preview generation
 * - Debug mode toggle for development testing
 * - Welcome screen with suggestions for new users
 * - Message persistence and state management
 * - Typing indicators and status updates
 * - Auto-scroll and message management
 * 
 * @example
 * ```tsx
 * <ChatInterface 
 *   onSDLGenerated={(sdl, template) => handleSDL(sdl, template)}
 *   onClose={() => setModalOpen(false)}
 * />
 * ```
 */
export const ChatInterface: React.FC<ChatInterfaceProps> = ({ 
  onSDLGenerated, 
  onClose 
}) => {
  const { sendStreamingMessage, testConnection } = useAkashAgent();
  const { 
    messages, 
    isAgentTyping, 
    shouldShowWelcome,
    connectionStatus,
    addUserMessage,
    addAgentMessage,
    addErrorMessage,
    setAgentTyping,
    setConnectionStatus
  } = useChatState();
  const { processAgentMessageForSDL } = useSDLGeneration();
  const messagesEndRef = useRef<HTMLDivElement>(null);
  
  // Debug mode to bypass connection requirement - allows testing chat UI without agent connection
  const [debugMode, setDebugMode] = React.useState(false);

  /**
   * Auto-scroll effect
   * Automatically scrolls chat to bottom when new messages arrive or typing status changes
   */
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages.length, isAgentTyping]);

  /**
   * Connection test function
   * Tests connectivity to the Akash Agent and updates connection status
   * Used for initial connection and retry attempts
   */
  const checkConnection = useCallback(async () => {
    try {
      setConnectionStatus('connecting');
      const isConnected = await testConnection();
      setConnectionStatus(isConnected ? 'connected' : 'disconnected');
    } catch (error) {
      console.error('Connection test failed:', error);
      setConnectionStatus('error');
    }
  }, [testConnection, setConnectionStatus]);

  /**
   * Initial connection test on component mount
   * Automatically attempts to connect to agent when chat interface loads
   */
  useEffect(() => {
    checkConnection();
  }, [checkConnection]);

  /**
   * Handles sending messages to the Akash Agent
   * 
   * This function manages the complete message flow:
   * 1. Adds user message to chat with optimistic UI
   * 2. In debug mode: simulates agent response for testing
   * 3. In normal mode: streams real agent response with action processing
   * 4. Processes any SDL content found in responses
   * 5. Calls onSDLGenerated callback if SDL is detected
   * 
   * @param userMessage - The message text from the user
   */
  const handleStreamingMessage = useCallback(async (userMessage: string) => {
    // Add user message immediately with optimistic UI
    addUserMessage(userMessage);
    setAgentTyping(true);

    try {
      // Debug mode: simulate response without connection
      if (debugMode) {
        // Simulate typing delay for realistic UX
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const mockResponse = `I received your message: "${userMessage}"\n\nThis is a debug response. In a real connection, I would help you with your deployment needs.`;
        addAgentMessage(mockResponse, { status: 'completed' });
        setAgentTyping(false);
        return;
      }

      // Normal mode: Stream agent response with real-time actions
      const finalResponse = await sendStreamingMessage(
        userMessage,
        handleAgentAction, // Processes intermediate actions during streaming
        300 // 5 minute timeout for complex operations
      );

      // Add final agent response if we have one
      if (finalResponse && finalResponse.trim()) {
        const finalMessage = addAgentMessage(finalResponse, {
          status: 'completed'
        });

        // Check if the final response contains SDL for deployment
        const sdlResult = processAgentMessageForSDL(finalResponse);
        if (sdlResult.hasSDL && sdlResult.sdl && sdlResult.template && onSDLGenerated) {
          onSDLGenerated(sdlResult.sdl, sdlResult.template);
        }
      }

    } catch (error) {
      console.error('Streaming message failed:', error);
      const errorMsg = error instanceof Error ? error.message : "I encountered an error processing your request. Please try again.";
      addErrorMessage(errorMsg);
    } finally {
      setAgentTyping(false);
    }
  }, [
    addUserMessage, 
    setAgentTyping, 
    sendStreamingMessage, 
    addAgentMessage, 
    addErrorMessage, 
    processAgentMessageForSDL, 
    onSDLGenerated
  ]);

  /**
   * Handles real-time agent actions during streaming
   * 
   * The agent sends various actions while processing user requests:
   * - chat: Real-time chat messages to show progress
   * - create_file/modify_file: File operations with SDL detection
   * - read_file: File reading operations
   * - run_subprocess: Command execution feedback
   * - list_directory: Directory exploration
   * - search_project: Project search operations
   * - complete: Task completion signals
   * 
   * @param action - The agent action object containing command, parameters, and result
   * @param count - Action sequence number for tracking
   */
  const handleAgentAction = useCallback((action: AgentAction, count: number) => {
    console.log(`[ChatInterface] Action ${count}:`, action.command, action.status);

    // Handle different action types with enhanced UX feedback
    switch (action.command) {
      case 'chat':
        // Real-time chat updates
        const chatContent = action.parameters?.message || action.result;
        if (chatContent && typeof chatContent === 'string' && chatContent.trim()) {
          addAgentMessage(chatContent, {
            status: action.status || 'completed',
            actionType: 'chat',
            sequenceIndex: action.sequence_index
          });
        }
        break;

      case 'create_file':
      case 'modify_file':
        // Enhanced file operations with SDL detection
        const filePath = action.parameters?.file_path;
        const fileContent = action.result;
        
        if (filePath) {
          let message = `I've ${action.command === 'create_file' ? 'created' : 'updated'} the file: ${filePath}`;
          
          // Enhanced SDL file detection
          const isSDLFile = filePath.endsWith('.yml') || filePath.endsWith('.yaml') || 
                           filePath.toLowerCase().includes('sdl') ||
                           filePath.toLowerCase().includes('deploy') ||
                           filePath.toLowerCase().includes('stack') ||
                           filePath.toLowerCase().includes('manifest');
          
          if (isSDLFile && fileContent) {
            const sdlResult = processAgentMessageForSDL(fileContent, action.command);
            if (sdlResult.hasSDL) {
              message = `I've ${action.command === 'create_file' ? 'created' : 'updated'} your SDL configuration:`;
              
              addAgentMessage(message, {
                status: action.status || 'completed',
                actionType: action.command,
                sequenceIndex: action.sequence_index,
                sdl: sdlResult.sdl
              });
              
              // Auto-trigger SDL generation for complete configurations
              if (sdlResult.sdl && sdlResult.template && onSDLGenerated) {
                const hasServices = sdlResult.sdl.includes('services:');
                const hasDeployment = sdlResult.sdl.includes('deployment:') || sdlResult.sdl.includes('version:');
                
                if (hasServices && hasDeployment) {
                  setTimeout(() => {
                    onSDLGenerated(sdlResult.sdl!, sdlResult.template!);
                  }, 1000); // Small delay for better UX
                }
              }
              return;
            }
          }
          
          addAgentMessage(message, {
            status: action.status || 'completed',
            actionType: action.command,
            sequenceIndex: action.sequence_index
          });
        }
        break;

      case 'read_file':
        // Enhanced file reading with better feedback
        const readFilePath = action.parameters?.file_path;
        if (readFilePath) {
          const fileName = readFilePath.split('/').pop() || readFilePath;
          addAgentMessage(`📖 Reading ${fileName}...`, {
            status: action.status || 'completed',
            actionType: 'read_file',
            sequenceIndex: action.sequence_index
          });
        }
        break;

      case 'run_subprocess':
        // Enhanced command execution display
        const command = action.parameters?.command;
        if (command) {
          // Truncate very long commands for better display
          const displayCommand = command.length > 60 ? `${command.substring(0, 60)}...` : command;
          addAgentMessage(`⚡ Executing: \`${displayCommand}\``, {
            status: action.status || 'completed',
            actionType: 'run_subprocess',
            sequenceIndex: action.sequence_index
          });
        }
        break;

      case 'list_directory':
        // Directory listing feedback
        const dirPath = action.parameters?.path || action.parameters?.directory;
        if (dirPath) {
          addAgentMessage(`📂 Exploring directory: ${dirPath}`, {
            status: action.status || 'completed',
            actionType: 'list_directory',
            sequenceIndex: action.sequence_index
          });
        }
        break;

      case 'search_project':
        // Project search feedback
        const searchTerm = action.parameters?.query || action.parameters?.term;
        if (searchTerm) {
          addAgentMessage(`🔍 Searching for: "${searchTerm}"`, {
            status: action.status || 'completed',
            actionType: 'search_project',
            sequenceIndex: action.sequence_index
          });
        }
        break;

      case 'complete':
        // Task completion
        setAgentTyping(false);
        break;

      case 'feedback':
        // Internal feedback - don't show to user
        break;

      default:
        // Enhanced generic action display
        const actionResult = action.result || 'Processing...';
        if (typeof actionResult === 'string' && actionResult.trim()) {
          addAgentMessage(`🔧 ${action.command}: ${actionResult}`, {
            status: action.status || 'completed',
            actionType: action.command,
            sequenceIndex: action.sequence_index
          });
        }
    }
  }, [addAgentMessage, setAgentTyping, processAgentMessageForSDL, onSDLGenerated]);


  return (
    <div 
      className="relative flex flex-col h-full bg-background overflow-hidden"
      role="application"
      aria-label="Akash AI Agent Chat Interface"
    >
      
      {/* Main chat area */}
      <div className="flex flex-col flex-1 min-h-0">
        {/* Content area */}
        <div className="flex-1 overflow-hidden">
          <AnimatePresence mode="wait">
            {shouldShowWelcome ? (
              <motion.div
                key="welcome"
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 1.05 }}
                transition={{ duration: 0.3, ease: "easeOut" }}
                className="h-full"
              >
                <ChatWelcomeScreen onSuggestionClick={handleStreamingMessage} />
              </motion.div>
            ) : (
              <motion.div
                key="messages"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                className="h-full overflow-hidden"
              >
                {/* Message list container */}
                <div 
                  role="log"
                  aria-live="polite"
                  aria-label="Chat conversation"
                  className="h-full"
                >
                  <ChatMessageList messages={messages} />
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
        
        {/* Typing indicator */}
        <AnimatePresence>
          {isAgentTyping && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: 'auto' }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.2 }}
              className="flex-shrink-0"
            >
              <TypingIndicator />
            </motion.div>
          )}
        </AnimatePresence>
        
        {/* Input area - fixed at bottom */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.1, duration: 0.3 }}
          role="form"
          aria-label="Send message to AI agent"
          className="flex-shrink-0 border-t bg-background/95 backdrop-blur-sm"
        >
          <ChatInput 
            onStreamingMessage={handleStreamingMessage}
            disabled={isAgentTyping || (!debugMode && connectionStatus !== 'connected')}
            connectionStatus={connectionStatus}
            onRetryConnection={checkConnection}
            debugMode={debugMode}
          />
        </motion.div>
        
        {/* Scroll anchor */}
        <div ref={messagesEndRef} />
      </div>
      
      {/* Debug toggle - subtle and out of sight */}
      <div className="absolute bottom-2 right-2 z-30">
        <button
          onClick={() => setDebugMode(!debugMode)}
          className={cn(
            "w-2 h-2 rounded-full transition-all duration-200 opacity-20 hover:opacity-60",
            debugMode ? "bg-green-500" : "bg-gray-400"
          )}
          title={debugMode ? "Debug mode ON" : "Debug mode OFF"}
          aria-label="Toggle debug mode"
        />
      </div>
    </div>
  );
};